{
  parserClass="org.legendofdragoon.fatescript.psi.FateScriptParser"
  parserUtilClass="com.intellij.lang.parser.GeneratedParserUtilBase"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="FateScript"
  psiImplClassSuffix="Impl"
  psiPackage="org.legendofdragoon.fatescript.psi"
  psiImplPackage="org.legendofdragoon.fatescript.psi.impl"

  elementTypeHolderClass="org.legendofdragoon.fatescript.psi.FateScriptTypes"
  elementTypeClass="org.legendofdragoon.fatescript.psi.FateScriptElementType"
  tokenTypeClass="org.legendofdragoon.fatescript.psi.FateScriptTokenType"

  tokens=[
    eol='regexp:\n+'
    whitespace='regexp:\s+'

    comma=','
    doublecolon='::'
    colon=':'
    lbracket='['
    rbracket=']'
    
    // Keyword ops
    yield='yield'
    return='return'
    rewind='rewind'

    // Loop ops
    while='while'

    // Wait ops
    wait='wait'
    wait_cmp='wait_cmp'

    // Bitwise ops
    and='and'
    or='or'
    xor='xor'
    andor='andor'
    not='not'
    shl='shl'
    shr='shr'

    // Math ops
    add='add'
    sub='sub'
    sub_rev='sub_rev'
    incr='incr'
    decr='decr'
    neg='neg'
    abs='abs'
    mul='mul'
    div='div'
    div_rev='div_rev'
    mod='mod'
    mod_rev='mod_rev'
    mul_12='mul_12'
    div_12='div_12'
    div_12_rev='div_12_rev'
    sqrt='sqrt'
    rand='rand'
    sin_12='sin_12'
    cos_12='cos_12'
    atan2_12='atan2_12'

    // Jump ops
    jmp='jmp'
    jmp_table='jmp_table'

    // Gosub ops
    gosub='gosub'
    gosub_table='gosub_table'

    // Script ops
    consume='consume'
    deallocate='deallocate'
    deallocate_other='deallocate_other'
    fork='fork'
    fork_reenter='fork_reenter'

    // Other ops
    call='call'
    mov='mov'
    memcpy='memcpy'

    // Useless ops
    swap_broken='swap_broken'
    depth='depth'
    noop='noop'

    // Datatypes
    entrypoint='entrypoint'
    data='data'
    rel='rel'

    // Subscriptable params
    inl='inl'
    var='var'
    stor='stor'
    str='str'

    comment='regexp:;.*'
    cmp='regexp:<=|<|>=|>|==|!=|&|!&'
    binop='regexp:[+\-*/]'
    id='regexp:[a-zA-Z_]\w*'
    method='regexp:[a-zA-Z_]\w*'
    dec='regexp:\d{1,10}'
    hex='regexp:0x[a-fA-F\d]{1,8}'
    string='regexp:\[.*]'
  ]

  name(".*root")='root'
  //extends(".*root")=root
}

/*root ::= line*
line ::= !<<eof>> entry? (<<eof>> | eol)
entry ::= entrypoint colon labelRef
labelRef ::= &colon id*/

root ::= line*
line ::= !<<eof>> (dataRef | relativeJump | entry | code | label colon)? (<<eof>> | eol) {pin=2 recoverWhile=lineRecover}
private lineRecover ::= !line

labelRef ::= labelRefLabel (lbracket (labelRef |  number | storageGroup) (binop (number | storageGroup))? rbracket)?
labelRefLabel ::= colon id
label ::= id &(colon)

code ::= op !colon params?

// Ops
private op ::= (keywordOps | while | waitOps | bitwiseOps | mathOps | jumpOps | gosubOps | scriptOps | otherOps | uselessOps)
keywordOps ::= return | yield | rewind
waitOps ::= wait | wait_cmp
bitwiseOps ::= and | or | xor | andor | not | shl | shr
mathOps ::= add | sub | sub_rev | incr | decr | neg | abs | mul | div | div_rev | mod | mod_rev | mul_12 | div_12 | div_12_rev | sqrt | rand | sin_12 | cos_12 | atan2_12
jumpOps ::= jmp | jmp_table
gosubOps ::= gosub | gosub_table
scriptOps ::= consume | deallocate | deallocate_other | fork | fork_reenter
otherOps ::= call | move | memcpy
uselessOps ::= swap_broken | depth | noop

params ::= param ((comma param)+)?
param ::= methodRef | number | inline | gameVarGroup | storageGroup | cmp | id

methodRef ::= id doublecolon method

// Inline
inline ::= inl lbracket (lbracket storageGroup rbracket | labelRef) (binop (inline | number | storageGroup))? rbracket

// GameVar
private gameVarGroup ::= gameVarArray | gameVarArrayOffsetNumber | gameVarArrayOffsetStorage | gameVar
gameVar ::= var lbracket number [binop (storage | number)] rbracket
gameVarArray ::= var lbracket number rbracket lbracket (number | storage) rbracket
gameVarArrayOffsetNumber ::= var lbracket number binop number rbracket lbracket storage rbracket
gameVarArrayOffsetStorage ::= var lbracket number binop storage rbracket lbracket (number | storage) rbracket

// Storage
private storageGroup ::= storage | otherStorage | otherStorageOffset | otherOtherStorage
storage ::= stor lbracket number rbracket
otherStorage ::= stor lbracket storage comma number rbracket
otherStorageOffset ::= stor lbracket storage comma number [binop storage] rbracket
otherOtherStorage ::= stor lbracket otherStorage comma number rbracket

entry ::= entrypoint labelRef
relativeJump ::= rel labelRef
dataRef ::= data (number | (str string))

number ::= dec | hex
